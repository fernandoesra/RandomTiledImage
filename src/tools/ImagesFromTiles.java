package tools;

import java.awt.Desktop;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Random;

import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

/**
 * This is the main class of the program. The object has two main methods for
 * program management. The <b>FillaArray()</b> method that will reset the
 * composition of the tiles and the <b>DrawTiles()</b> method that cycles
 * through the composition and draws it and then saves it.
 * 
 * @author Fernando Tarrino del Pozo (FernandoEsra)
 * @see Main
 */

public class ImagesFromTiles {

	/**
	 * Bidimensional array of ints where the pattern will be generated that will
	 * later be exported to an image.
	 */
	public int[][] numbers;
	/**
	 * Array height.
	 */
	public int height;
	/**
	 * Array width.
	 */
	public int width;
	/**
	 * Height of the image we want to generate in pixels.
	 */
	public int originalHeight;
	/**
	 * Width of the image we want to generate in pixels.
	 */
	public int originalWidth;
	/**
	 * If there are images of 16 pixels x 16 pixels, they will be stored in this
	 * array.
	 */
	public List<BufferedImage> tiles16x16;
	/**
	 * If there are images of 32 pixels x 16 pixels, they will be stored in this
	 * array.
	 */
	public List<BufferedImage> tiles32x16;
	/**
	 * If there are images of 16 pixels x 32 pixels, they will be stored in this
	 * array.
	 */
	public List<BufferedImage> tiles16x32;
	/**
	 * If there are images of 32 pixels x 32 pixels, they will be stored in this
	 * array.
	 */
	public List<BufferedImage> tiles32x32;
	/**
	 * If there are images of 48 pixels x 16 pixels, they will be stored in this
	 * array.
	 */
	public List<BufferedImage> tiles48x16;
	/**
	 * If there are images of 16 pixels x 48 pixels, they will be stored in this
	 * array.
	 */
	public List<BufferedImage> tiles16x48;
	/**
	 * Variable that controls whether the generated image will be opened at the end
	 * of the program or not.
	 */
	public boolean preview;
	/**
	 * Variable that controls whether the name of the generated file is given by the
	 * user or is generated automatically by the program (without extension).
	 */
	public String outputName;

	/**
	 * Class constructor. The input arguments are controlled by the Main class and
	 * are either given or not given by the user.
	 * 
	 * @param height     This height value will be used for both the data array and
	 *                   the generated image.
	 * @param width      This width value will be used for both the data array and
	 *                   the generated image.
	 * @param preview    If <b>true</b>, when the program ends the operating system
	 *                   image manager opens and the generated image is displayed.
	 *                   If it is <b>false</b>, the program will run from start to
	 *                   finish without opening anything extra.
	 * @param outputName This value <b>can be null</b>, if so the file name will be
	 *                   generated by the program using a timestamp. If the value is
	 *                   not null, it will be used to name the generated file.
	 */
	ImagesFromTiles(int height, int width, boolean preview, String outputName) {
		this.height = (height / 16) + 1;
		this.width = (width / 16) + 1;
		originalWidth = width;
		originalHeight = height;
		this.preview = preview;
		if (outputName != null) {
			this.outputName = outputName;
		}
		FetchTiles();
	}

	/**
	 * Starts the array back to the values given in the constructor. By default Java
	 * fills the array with 0, this way we can use the same object if we want to
	 * generate different variations.
	 */
	public void InitiateArray() {
		numbers = new int[height][width];
	}

	/**
	 * First we start the array to clean it, then we go through the array and fill
	 * it with different numbers that will have their equivalent in tiles.
	 * <p>
	 * <b>Equivalences:</b> <br>
	 * 
	 * <pre>
	 * +-----------------------------+
	 * | int value | Tile dimensions |
	 * +-----------------------------+
	 * |     1     |      16x16      |
	 * +-----------------------------+
	 * |     2     |      16x32      |
	 * +-----------------------------+
	 * |     3     |      32x16      |
	 * +-----------------------------+
	 * |     4     |      32x32      |
	 * +-----------------------------+
	 * |     5     |      16x48      |
	 * +-----------------------------+
	 * |     6     |      48x16      |
	 * +-----------------------------+
	 * </pre>
	 * 
	 * For each number, the initial coordinate (upper left) will be filled with the
	 * indicated number and the rest with -1 to indicate that they are reserved. For
	 * example if we have the following:
	 * 
	 * <pre>
	 * +---------+
	 * |1|1|2|2|3|
	 * +---------+
	 * |4|4|1|1|3|
	 * +---------+
	 * |4|4|2|2|1|
	 * +---------+
	 * </pre>
	 * 
	 * In the array we will have:
	 * 
	 * <pre>
	 * +--------------+
	 * | 1| 1| 2|-1| 3|
	 * +--------------+
	 * | 4|-1| 1| 1|-1|
	 * +--------------+
	 * |-1|-1| 2|-1| 1|
	 * +--------------+
	 * </pre>
	 * 
	 * In addition, there are different protections to <b>avoid generating tiles
	 * that do not exist in the files</b>. For example, if there are no 32x32 tiles,
	 * they will not be generated in those sizes.
	 */
	public void FillArray() {
		InitiateArray();
		for (int i = 0; i < height; i++) {
			for (int j = 0; j < width; j++) {
				if (IsValid(i, j)) {
					int toAdd = RandomValue(PossibleTwo(i, j), PossibleThree(i, j), PossibleFour(i, j),
							PossibleFive(i, j), PossibleSix(i, j));
					if (toAdd == 2) {
						numbers[i][j] = toAdd;
						numbers[i][j + 1] = -1;
					} else if (toAdd == 3) {
						numbers[i][j] = toAdd;
						numbers[i + 1][j] = -1;
					} else if (toAdd == 4) {
						numbers[i][j] = toAdd;
						numbers[i + 1][j] = -1;
						numbers[i][j + 1] = -1;
						numbers[i + 1][j + 1] = -1;
					} else if (toAdd == 5) {
						numbers[i][j] = toAdd;
						numbers[i][j + 1] = -1;
						numbers[i][j + 2] = -1;
					} else if (toAdd == 6) {
						numbers[i][j] = toAdd;
						numbers[i + 1][j] = -1;
						numbers[i + 2][j] = -1;
					} else
						numbers[i][j] = toAdd;
				}
			}
		}
	}

	/**
	 * Returns a value of type int to fill the array. There are different
	 * protections to know if a type of tile can be generated or not. The
	 * probabilities of each number are:
	 * 
	 * <pre>
	 * +-------------------------+
	 * | int value | Probability |
	 * +-------------------------+
	 * |     1     |     50%     |
	 * +-------------------------+
	 * |     2     |     10%     |
	 * +-------------------------+
	 * |     3     |     10%     |
	 * +-------------------------+
	 * |     4     |     10%     |
	 * +-------------------------+
	 * |     5     |     10%     |
	 * +-------------------------+
	 * |     6     |     10%     |
	 * +-------------------------+
	 * </pre>
	 * 
	 * @param two   Checks if there are 32x16 tiles in the corresponding array to be
	 *              able to generate them.
	 * @param three Checks if there are 16x32 tiles in the corresponding array to be
	 *              able to generate them.
	 * @param four  Checks if there are 32x32 tiles in the corresponding array to be
	 *              able to generate them.
	 * @param five  Checks if there are 48x16 tiles in the corresponding array to be
	 *              able to generate them.
	 * @param six   Checks if there are 16x48 tiles in the corresponding array to be
	 *              able to generate them.
	 * @return A correct Integer value to assign to the composition.
	 */
	public int RandomValue(boolean two, boolean three, boolean four, boolean five, boolean six) {

		boolean one = true;
		List<Integer> valid = new ArrayList<>();

		if (tiles16x16.size() != 0) {
			valid.add(1);
		}
		if (tiles32x16.size() != 0 && two) {
			valid.add(2);
			valid.add(1);
		}
		if (tiles16x32.size() != 0 && three) {
			valid.add(3);
			valid.add(1);
		}
		if (tiles32x32.size() != 0 && four) {
			valid.add(4);
			valid.add(1);
		}
		if (tiles48x16.size() != 0 && five) {
			valid.add(5);
			valid.add(1);
		}
		if (tiles16x48.size() != 0 && six) {
			valid.add(6);
			valid.add(1);
		}

		if (valid.size() == 0) {
			System.out.println("No tiles detected");
			System.exit(0);
		}

		int random = new Random().nextInt(valid.size());

		return valid.get(random);
	}

	/**
	 * Checks if provided coordinate are within the limits of the array
	 * 
	 * @param x The coordinate for the height
	 * @param y The coordinate for the width
	 * @return <b>True</b> if the coordinate is within the limits, <b>false</b> if
	 *         not
	 */
	public boolean InBounds(int x, int y) {
		if (x < 0 || x >= height || y < 0 || y >= width)
			return false;
		else
			return true;
	}

	/**
	 * Checks if the provided coordinate is valid (it is within the limits of the
	 * array and has a 0 inside)
	 * 
	 * @param x The coordinate for the height
	 * @param y The coordinate for the width
	 * @return <b>True</b> if the coordinate is valid, <b>false</b> if not
	 */
	public boolean IsValid(int x, int y) {
		if (InBounds(x, y)) {
			if (numbers[x][y] == 0)
				return true;
		}
		return false;
	}

	/**
	 * Check if it is possible to generate the shape assigned to number 2 (a 16
	 * pixels high and 32 pixels wide tile). To do this, it checks whether both the
	 * given coordinate and the next coordinate (width + 1) are valid.
	 * 
	 * @param x The coordinate for the height
	 * @param y The coordinate for the width
	 * @return <b>True</b> if the form can be generated, <b>false</b> if not
	 */
	public boolean PossibleTwo(int x, int y) {
		if (IsValid(x, y + 1))
			return true;
		return false;
	}

	/**
	 * Check if it is possible to generate the shape assigned to number 3 (a 32
	 * pixels high and 16 pixels wide tile). To do this, it checks if the given
	 * coordinate and the lower coordinate (height + 1) are valid.
	 * 
	 * @param x The coordinate for the height
	 * @param y The coordinate for the width
	 * @return <b>True</b> if the form can be generated, <b>false</b> if not
	 */
	public boolean PossibleThree(int x, int y) {
		if (IsValid(x + 1, y))
			return true;
		return false;
	}

	/**
	 * Check if it is possible to generate the shape assigned to number 4 (a 32
	 * pixels high and 32 pixels wide tile). To do this, check if the following
	 * coordinates are valid:
	 * <p>
	 * - The given coordinate<br>
	 * - The next coordinate in height (height + 1)<br>
	 * - The next coordinate in width (width + 1)<br>
	 * - The adjacent coordinate vertically moving forward (height +1 and width + 1)
	 * 
	 * @param x The coordinate for the height
	 * @param y The coordinate for the width
	 * @return <b>True</b> if the form can be generated, <b>false</b> if not
	 */
	public boolean PossibleFour(int x, int y) {
		if (IsValid(x + 1, y) && IsValid(x, y + 1) && IsValid(x + 1, y + 1))
			return true;
		return false;
	}

	/**
	 * Check if it is possible to generate the shape assigned to number 2 (a 16
	 * pixels high and 48 pixels wide tile). To do this, check if the following two
	 * width coordinates are valid (width + 1 and width + 2)
	 * 
	 * @param x The coordinate for the height
	 * @param y The coordinate for the width
	 * @return <b>True</b> if the form can be generated, <b>false</b> if not
	 */
	public boolean PossibleFive(int x, int y) {
		if (IsValid(x, y + 1) && IsValid(x, y + 2))
			return true;
		return false;
	}

	/**
	 * Check if it is possible to generate the shape assigned to number 2 (a 48
	 * pixels high and 16 pixels wide tile). To do this, check if the following two
	 * height coordinates are valid (height + 1 and height + 2)
	 * 
	 * @param x The coordinate for the height
	 * @param y The coordinate for the width
	 * @return <b>True</b> if the form can be generated, <b>false</b> if not
	 */
	public boolean PossibleSix(int x, int y) {
		if (IsValid(x + 1, y) && IsValid(x + 2, y) && IsValid(x + 3, y))
			return true;
		return false;
	}

	/**
	 * This method starts all the arrays where we will save the images and will
	 * search the <b>Tiles folder</b> (which must be in the same path where the code
	 * is executed) for the different images and depending on their size, it will
	 * save them in the arrays.
	 * <p>
	 * This method can throw an exception of type IOException if the Tiles folder
	 * does not exist.
	 * 
	 * @see IOException
	 */
	public void FetchTiles() {
		File folder = new File("./Tiles");
		File[] files = folder.listFiles();
		tiles16x16 = new ArrayList<>();
		tiles32x16 = new ArrayList<>();
		tiles16x32 = new ArrayList<>();
		tiles32x32 = new ArrayList<>();
		tiles48x16 = new ArrayList<>();
		tiles16x48 = new ArrayList<>();

		try {
			for (int i = 0; i < files.length; i++) {
				BufferedImage image = ImageIO.read(files[i]);
				if (image.getWidth() == 16 && image.getHeight() == 16) {
					tiles16x16.add(image);
				} else if (image.getWidth() == 32 && image.getHeight() == 16) {
					tiles32x16.add(image);
				} else if (image.getWidth() == 16 && image.getHeight() == 32) {
					tiles16x32.add(image);
				} else if (image.getWidth() == 32 && image.getHeight() == 32) {
					tiles32x32.add(image);
				} else if (image.getWidth() == 48 && image.getHeight() == 16) {
					tiles48x16.add(image);
				} else if (image.getWidth() == 16 && image.getHeight() == 48) {
					tiles16x48.add(image);
				}

			}
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	/**
	 * This method will be responsible for drawing the images based on the numbers
	 * generated in the composition array within a JFrame to later use a custom
	 * TilePanel and obtain the graphics with the use of Graphics2D.
	 * 
	 * If the preview variable is true, at the end of the entire process it will use
	 * a Desktop object to open the system image manager and be able to see the
	 * result.
	 * 
	 * This method may throw an IOException if it is not possible to save the
	 * resulting image.
	 * 
	 * @see IOException
	 * @see TilePanel
	 * @see JFrame
	 * @see BufferedImage
	 * @see Graphics2D
	 * @see java.desktop/
	 * @see Desktop
	 * 
	 */
	public void DrawTiles() {
		JFrame frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		frame.setSize(originalWidth, originalHeight);

		TilePanel panel = new TilePanel();

		BufferedImage buffer = new BufferedImage(frame.getWidth(), frame.getHeight(), BufferedImage.TYPE_INT_RGB);
		Graphics2D g2d = buffer.createGraphics();
		panel.paintComponent(g2d);
		g2d.dispose();

		BufferedImage image = new BufferedImage(frame.getWidth(), frame.getHeight(), BufferedImage.TYPE_INT_RGB);
		Graphics graphics = image.getGraphics();
		graphics.drawImage(buffer, 0, 0, null);
		graphics.dispose();
		try {

			String outputFileName = null;
			if (outputName != null) {
				outputFileName = outputName + ".png";
			} else {
				Date date = new Date();
				SimpleDateFormat sdf = new SimpleDateFormat("HHmmssddMMyyyy");
				String formattedDate = sdf.format(date);
				outputFileName = formattedDate + "_output.png";
			}

			ImageIO.write(image, "png", new File(outputFileName));

			if (preview) {
				File outputFile = new File(outputFileName);
				Desktop.getDesktop().open(outputFile);
			}

		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	/**
	 * Class that inherits from JPanel and we use to override the
	 * paintComponent(Graphics) method. With this method we will draw our tiles.
	 * This method runs through the array and draws the tiles at the indicated
	 * coordinates (in pixels).
	 * 
	 * @see JPanel
	 */
	private class TilePanel extends JPanel {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;

		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g);
			for (int i = 0; i < numbers.length; i++) {
				for (int j = 0; j < numbers[i].length; j++) {
					BufferedImage tile = null;
					int x = j * 16;
					int y = i * 16;
					int interior = numbers[i][j];
					switch (interior) {
					case 1:
						tile = tiles16x16.get((int) (Math.random() * tiles16x16.size()));
						break;
					case 2:
						tile = tiles32x16.get((int) (Math.random() * tiles32x16.size()));
						break;
					case 3:
						tile = tiles16x32.get((int) (Math.random() * tiles16x32.size()));
						break;
					case 4:
						tile = tiles32x32.get((int) (Math.random() * tiles32x32.size()));
						break;
					case 5:
						tile = tiles48x16.get((int) (Math.random() * tiles48x16.size()));
						break;
					case 6:
						tile = tiles16x48.get((int) (Math.random() * tiles16x48.size()));
						break;
					default:
						break;
					}
					if (interior != 7)
						g.drawImage(tile, x, y, null);
				}
			}
		}

	}

	/**
	 * Method for debugging. It is used to see on the screen all the tiles that the
	 * arrays have.
	 */
	public void ShowTiles() {
		JFrame win = new JFrame();
		win.setLayout(new GridLayout(3, 1));
		win.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		win.setSize(800, 600);

		JPanel panel16x16 = new JPanel();
		panel16x16.setLayout(new GridLayout(1, tiles16x16.size()));
		for (BufferedImage image : tiles16x16) {
			JLabel label = new JLabel(new ImageIcon(image));
			panel16x16.add(label);
		}
		win.add(panel16x16);

		JPanel panel32x16 = new JPanel();
		panel32x16.setLayout(new GridLayout(1, tiles32x16.size()));
		for (BufferedImage image : tiles32x16) {
			JLabel label = new JLabel(new ImageIcon(image));
			panel32x16.add(label);
		}
		win.add(panel32x16);

		JPanel panel16x32 = new JPanel();
		panel16x32.setLayout(new GridLayout(1, tiles16x32.size()));
		for (BufferedImage image : tiles16x32) {
			JLabel label = new JLabel(new ImageIcon(image));
			panel16x32.add(label);
		}
		win.add(panel16x32);

		JPanel panel32x32 = new JPanel();
		panel32x32.setLayout(new GridLayout(1, tiles32x32.size()));
		for (BufferedImage image : tiles32x32) {
			JLabel label = new JLabel(new ImageIcon(image));
			panel32x32.add(label);
		}
		win.add(panel32x32);

		win.setVisible(true);
	}

	/**
	 * Print the contents of the composition array
	 */
	@Override
	public String toString() {
		String map = "";
		for (int i = 0; i < height; i++) {
			for (int j = 0; j < width; j++) {
				map += numbers[i][j];
			}
			map += "\n";
		}
		return map;
	}

}
